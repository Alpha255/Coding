虽然标题是Unity DOTS, 其实Unity DOTS包含了很多东西, 包括DOTS的物理, DOTS的渲染等等, 明年Unity可能会有一个大版本去全面推行DOTS的架构, 我们今天主要简单介绍一下
Unity的ECS架构, 它也是Unity DOTS的重要组成部分

DOTS的全称是Data Oriented Tech Stack, 中文就是数据驱动的技术栈, 它的核心构件主要有这三个, 一个就是ECS, Entity Component System, 实体组件系统, 另一个是JobSystem,
是Unity的一个用来做并发任务的库, 还有一个就是Burst Compiler, 它是一个基于LLVM的编译器, 我们知道Unity是通过Mono来实现跨平台的, 本质上就是在虚拟机上运行c#代码, 
而有了Burst Compiler, 我们就可以直接将C#字节码转换成平台相关并且高度优化的机器码, 以此来提高性能, 并且Burst Compiler本身是math aware, 也就是数学敏感的编译器, 结合
unity新的数学库, 更有助于做SIMD, 也就是单指令流多数据流, 这三个部分就构成了DOTS的基底, 目前这些构件都能通过package manager安装使用, 但是都是预览版, 且接口更新比较频繁,
明年的大版本里面可能会有很大的不同.

其实ECS并不是一个新鲜的概念, 很早以前就有商业项目使用过这个架构, 最早可能追溯到98年的神偷项目(未经证实), 07年的闪点行动中也使用了ECS架构, 而ECS真正开始受到广泛关注起源
于守望先锋的开发者在GDC 2017上的一个演讲(Overwatch Gameplay Architecture and Netcode). 有兴趣的可以去看看, 有一个小时.

那么unity为什么要推行这么一个架构, 传统的游戏引擎如何处理游戏逻辑的更新, 目前传统的游戏引擎一般是基于面向对象来设计的, 一般每个对象都有一个Update方法, 引擎会在运行时遍历
所有的对象, 调用它们的Update方法, 这在逻辑上非常的合理清晰自然, 但其实也有不少缺陷: 通常一个游戏对象都有多个模块聚合而成, 但这些模块往往互不相关, 这就导致模块的内聚性较差, 
增加了模块间的耦合度, 游戏对象中往往数据和逻辑都混合在一起, 使得代码结构不是那么清晰, 并且这些GameObject在内存中通常都是不连续的, 这就导致Cpu在访问GameObject的数据成员时, 
可能会有严重的Cache miss, 而且我们往往不需要访问所有的数据成员, 比如说我们只需要给某个object移动位置, 只需要访问它的position数据就够了, 但是我们不得不把object的整个数据块
都丢给cpu, 这就造成了内存的浪费, 面向对象是以对象优先，每次是对自己对象的处理，对其他对象的影响，需要使用消息驱动.ECS是以Component优先，不会有这个问题, 因为颗粒度更加小，
比如两个对象A和B, A对B造成了伤害，传统的oop会纠结于在A中计算还是B中计算，但是ecs在system中完成, 不需要关心实际的计算发生在哪个对象中, 另外就是Mono和GC会带来一定的性能损耗, 
以及使用单线程编程, 无法充分利用现代cpu的多核优势.

ECS用Entity取代了GameObject, Entity可以当做一个更轻量级的GameObject, 其次是将逻辑处理与数据分离, 也就是解耦, 由Component来保存数据, System专门负责逻辑处理, 这样组件中就不包含
逻辑, 系统中就不包含数据, 并且结构也更加清晰, 组件通常使用struct, 避免GC, 而且这种结构更加易于我们做并发, 利用新的数学库和JobSystem以及Burst Compiler, 充分发挥SIMD的优势,
另外compnent的数据就是状态的数据, 易于保存关键状态和做回滚,预测, 更容易实现网络同步

目前Unity的ECS还分为Hybrid ECS和Pure ECS两种, Hybrid ECS的存在是为了兼容现有的引擎架构, 这种结构下我们可以在初始化时或运行时将GameObject转换成Entity, GameObject的Inspector界面
仍然可以使用, 需要给object挂载一个ConvertToEntity的脚本, 所以叫混合, Pure ECS, 顾名思义, 就是完全使用Entity取代object, 明年的大版本中可能就会是这种结构, ECS需要我们从根本上转变
编程思想, 重新设计我们的游戏框架来适应ECS这么一个架构

简单示例, 不用ECS, 一次性spawn几百个子弹会造成卡顿, 用了ECS就流畅很多

ECS的几个核心组成部分, 首先是三要素 (Entity, Component, System), 然后再加上世界, 原型和chunk, 这边是ECS架构的一个简单示意图, World包含了多个子系统和多个entity, entity管理了它的各个组件

Entity相当于一个非常轻量化的GameObject, 它只有两个成员, Index和Version, 其中Index就代表了Entity的ID, 当Entity被销毁的时候, index会被回收,
index也代表了这个entity在内存块中的索引, 比如有时我们只需要访问某一个entity的组件, 就可以通过这个index直接找到这个entity相关的组件, 
在entity被销毁的时候, Version也会增加, 可以说Version代表了Entity的生命周期, 只有当Index和Version都匹配的时候, 才代表这个Entity存在
所以Entity的本质就是一个ID, 它不包含任何的逻辑或者数据, 但可以按照与Entity相关联的组件类型对其进行分类

Component, 组件只包含Entity的实例数据, 通常需要使用struct来声明, 不能包含引用对象, 因此没有GC, 但是也可以用class来声明Component, 这类Component称为托管型的组件, 在我们将旧项目移植到ECS
框架时可能会有用,但托管型的组件不能使用Burst Compiler, 不能使用Job System, 不能使用Chunk, 需要GC, 因此性能较差, 组件一共有以下几种, 常用的就是IComponentData和ISharedComponentData, 其中
IComponentData就是一般性的组件, 而共享组件是一种特殊的组件, 通常将Mesh, materia这类被许多entity所共有的数据放到共享组件中, 每个Chunk会存放一个表示共享组件的索引, 过度使用共享组件可能会导
致Chunk的利用率下降, 因为它涉及基于原型和每个共享组件字段的每个唯一值组合扩展所需的内存块数量. 另外要注意的是从Entity中增加或者删除一个组件,会导致这个Entity被移动到一个另一个Chunk中, 
必要时会分配新的Chunk, 所以我们尽量不要在运行时添加或者删除组件, 这样会导致性能下降.

System提供了将组件数据从当前状态转换为下一个状态的逻辑, 我们在设计的时候, 每个系统都应该专注于某一类事件, 比如碰撞系统, 就只关心对象的体积和位置, 不必关心对象的名字, 连接状态, 音效,敌对关系等, 
另外就是某个系统也应该只关注某一类对象, 比如碰撞系统只需要关注世界中能够产生碰撞的entity,每个系统都应该先筛选出所感兴趣的一类entity,然后进行更新操作.比如图中系统读取Translation和Rotation组件，
将它们相乘然后更新相应的LocalToWorld 组件, 虽然A和B上有Renderer组件，而实体C没有, 但不会影响该系统, 因为系统不关心Renderer组件.
通常我们需要扩展ComponentSystem或者JobComponentSystem
其中ComponentSystem在主线程上执行, JobComponentSystem可以将Job安排到Worker Thread上, 充分利用Cpu多核

默认情况下，ComponentSystemGroup 的 OnUpdate() 方法会按照成员系统（member system）的顺序来调用他们的 Update()，如果成员系统也是一个系统组，那么这个系统组也会递归地更新它的成员系统。总体的系统遵循树的深度优先遍历。
[UpdateInGroup] 指定某个系统成为一个 ComponentSystemGroup 中的成员系统。如果没有用这个属性，这个系统会自动被添加到默认世界（default World）的 SimulationSystemGroup 中。
[UpdateBefore] 和 [UpdateAfter] 指定系统相对于其他系统的更新顺序。这两个系统必须在同一个系统组（system group）中，前文说到系统组也可以嵌套，因此只要两个系统身处同一个根系统组即可。
[DisableAutoCreation] 阻止系统从默认的世界初始化中创建或添加到世界中。这时候我们需要显式地创建和更新系统。然而我们也可以把这个系统和它的标记（tag）加到 ComponentSystemGroup 的更新列表中（update list），这样这个系统会正常地自动更新。

JobComponentSystem 能帮我们自动管理依赖。原理很简单，来自不同系统的Job可以并行地读取相同类型的IComponentData.所有 Jobs 和系统会声明它们会读/写哪些组件类型, 
JobComponentSystem 返回的 JobHandle 依赖句柄会自动注册到 EntityManager 中，以及所有包含读或写（reading or writing）信息的类型中。
如果其中一个 Job 正在写（write）数据，那么所有的 Job 就不能并行地执行，而是设定它们的依赖来安排执行顺序。
JobComponentSystem 简单地按照需求维护一个依赖链，这样不会对主线程造成影响。
依赖管理是保守的,
但是如果一个非 Job 的 ComponentSystem 要存取（access）相同的数据会怎么样呢？因为所有的存取都是声明好的，因此对于所有 ComponentSystem 需要进行存取的组件类型（component type）相关联的 Jobs，ComponentSystem 都会先自动完成这些相关的 Jobs，再在 OnUpdate 中调用依赖。

它提供的指导方案就是 Component 是纯数据组合，没有任何操作这个数据的方法；而 System 是纯方法组合，它自己没有内部状态。
每个 System 都可以独立开发，它只需要遍历给框架提供给它的组件集合，做出正确的处理，更新组件状态就够了。

World
例如可以创建一个World做逻辑运算, 另一个World做渲染

Archetype
表示一个或多个Component类型的集合, Archetype=>Chunk=>内存排布, 动态添加或删除Component会导致内存重排
这种组织方式就在原型与Chunk之间提供了一对多的关系, 也就是说要检索具有给定组件的所有entity, 仅需要搜索通常数量不多的原型就可以了, 而不用去对每个entity进行检索

Chunk 16KB

